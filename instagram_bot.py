# -*- coding: utf-8 -*-
"""Instagram Bot.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yQHIa9j8jPnXQb_DErEpmKB6ireGvqyv

Importing libraries
"""

import selenium
from selenium import webdriver
from selenium.common.exceptions import NoSuchElementException
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from bs4 import BeautifulSoup as bsp
import bs4
import time
import pandas as pd

## Username & Password
username = "user"        
password = "password"

"""Setting up Chrome WebDriver and visting Instagram"""

driver=webdriver.Chrome(r'C:\Users\GhostRider\Desktop\InstaBot\chromedriver.exe')
#set the location where the chrome driver is located.

driver.get("https://www.instagram.com/")
driver.maximize_window()

"""## 1. Log in to Instagram Handle"""

## function for log in

def log_in_to_account(driver, username, password):
    
    login = True
    
    wait = WebDriverWait(driver, 10)  ## explicit wait
    
    try:
        ## move to login page
        log_in_path = '//p[@class = "izU2O"]//a'
        log_in = wait.until(EC.element_to_be_clickable((By.XPATH,log_in_path)))
        log_in.click()

        time.sleep(3)   ## waiting for website to switch

        ## enter username
        username_ = wait.until(EC.presence_of_element_located((By.NAME,"username")))
        username_.send_keys(username)

        ## enter password
        password_ = wait.until(EC.presence_of_element_located((By.NAME,"password")))
        password_.send_keys(password)

        ## click login
        log_in_path = '//button[contains(@class, "sqdOP")]'
        log_in = wait.until(EC.presence_of_element_located((By.XPATH,log_in_path)))
        log_in.submit()

        time.sleep(3)  ## waiting for website to switch
        
    except Exception:
        login = False
        
    if login:
        remove_notification(driver, wait)
    
    return login

def remove_notification(driver, wait):
    ## Notifination popup setting up not now, if occur
    try:
        popup_path = '//button[contains(@class, "HoLwm")]'
        not_now_btn = wait.until(EC.element_to_be_clickable((By.XPATH,popup_path)))
        not_now_btn.click()
    except NoSuchElementException:
        print("No Notification Pop up occur")

## 1

login = log_in_to_account(driver, username, password)
if login:
    print("log in successfully")
else:
    print("log in unseccussful, give one more try")

"""## 2. Searching Food """

## function to search something string like 'food' here

def Search_Handle(driver, string):
    
    wait = WebDriverWait(driver, 10)       ## Explicit Wait
    
    ## search 'food' 
    search_path = '//input[contains(@class, "x3qfX")]'
    search_bar = wait.until(EC.presence_of_element_located((By.XPATH,search_path)))
    search_bar.send_keys(string)
    time.sleep(3)
    
    ## Extracting the handles
    handles = []
    lst = driver.find_elements_by_class_name("Ap253")
    for i in lst:
        handle = i.get_attribute("innerHTML")
        if handle[0] == "#":
            handle = handle[1:]
        handles.append(handle)
        
    ## Erasing string from search bar
    path = '//div[contains(@class, "coreSpriteSearchClear")]'
    remove_btn = wait.until(EC.element_to_be_clickable((By.XPATH,path)))
    remove_btn.click()
        
    return handles

## 2

string = "food"     ## can be changed
handle_list = Search_Handle(driver, string)
cnt = 1
for i in handle_list:
    print(cnt, ".", i)
    cnt += 1

"""## 3. Search & Open "So Delhi" Profile"""

## function for search_open the profile

def search_open(driver, profile):
    
    open_ = True
    
    wait = WebDriverWait(driver, 10)       ## Explicit Wait
    
    try:
        ## search 'So Delhi' 
        search_path = '//input[contains(@class, "x3qfX")]'
        search_bar = wait.until(EC.presence_of_element_located((By.XPATH,search_path)))
        search_bar.send_keys(profile)

        ## open
        path = '//a[contains(@class, "yCE8d")]'
        btn = wait.until(EC.element_to_be_clickable((By.XPATH,path)))
        btn.click()
    except Exception:
        open_ = False
        
    return open_

## function for closing profile or returning home page

def close_profile(driver):
    wait = WebDriverWait(driver, 10)
    home = wait.until(EC.element_to_be_clickable((By.XPATH, '//div[@class = "oJZym"]/a')))
    home.click()

## 3

profile = "So Delhi"  ## can be changed

## opening profile
open_ = search_open(driver, profile)
if open_:
    print("Profile is successfully opened")
else:
    print("Profile is not opened, try again")
    
    
time.sleep(3)


## Closing profile
close_profile(driver)

"""## 4. Follow / Unfollow"""

## function to follow a given handle/profile

def follow(driver, profile):
    
    previously_follow = False
    
    wait = WebDriverWait(driver, 10)       ## Explicit Wait
    
    ## opening profile
    search_open(driver, profile)
    
    ## following handle
    path = '//button[contains(@class, "_5f5mN")]'
    btn = wait.until(EC.presence_of_element_located((By.XPATH,path)))
    
    ## Checking if i am following or not
    if(btn.get_attribute('innerHTML') == "Follow"):
        btn = wait.until(EC.element_to_be_clickable((By.XPATH,path)))
        btn.click()
    else:
        previously_follow = True
        
    ## coming back to home page
    home = wait.until(EC.element_to_be_clickable((By.XPATH, '//div[@class = "oJZym"]/a')))
    home.click()
    
    return previously_follow

## function to unfollow a given profile

def unfollow(driver, profile):
    
    previously_unfollow = False
    
    wait = WebDriverWait(driver, 10)       ## Explicit Wait
    
    ## opening profile
    search_open(driver, profile)
    
    ## unfollowing handle
    path = '//button[contains(@class, "_5f5mN")]'
    btn = wait.until(EC.presence_of_element_located((By.XPATH,path)))
    
    ## Checking if i am unfollowing or not
    if(btn.get_attribute('innerHTML') != "Follow"):
        btn = wait.until(EC.element_to_be_clickable((By.XPATH,path)))
        btn.click()
        
        ## unfollowing
        path = '//button[contains(@class, "aOOlW ")]'
        btn = wait.until(EC.element_to_be_clickable((By.XPATH,path)))
        btn.click()
    else:
        previously_unfollow = True
        
    ## coming back to home page
    home = wait.until(EC.element_to_be_clickable((By.XPATH, '//div[@class = "oJZym"]/a')))
    home.click()
    
    return previously_unfollow

## 4

profile = "So Delhi"        ## can be changed

## follow
previously_follow = follow(driver, profile)
if(previously_follow):
    print("Already Following")
else:
    print("Start Following")
    
    
time.sleep(3)    


## unfollow
previously_unfollow = unfollow(driver, profile)
if(previously_unfollow):
    print("Already not Following")
else:
    print("Start Unfollowing")

"""## 5. Like / Unlike """

## function to liking the first no_of_post of a profile

def like(driver, profile, no_of_post):
    
    wait = WebDriverWait(driver, 10)       ## Explicit Wait
    
    previously_like = False
    
    ## opening profile
    search_open(driver, profile)
    
    ## Extracting The No_of_posts
    btn = driver.find_elements_by_class_name("_bz0w")
    path = "//div[contains(@class,'_bz0w')]/a"
    btn = wait.until(EC.presence_of_all_elements_located((By.XPATH,path)))
    while len(btn) < no_of_post:
        driver.execute_script('window.scrollBy(0, 1000);')         ## Scrolling
        btn = wait.until(EC.presence_of_all_elements_located((By.XPATH,path)))
        
    print("number of posts extracted: ", len(btn))
    
    cnt = 1
    for i in btn:
        i.click()
        time.sleep(3)
        
        ## Checking if ith post is liked before or not
        cond = driver.find_elements_by_xpath("//*[name()='svg']")[6]
        if(cond.get_attribute("aria-label") == "Like"):    ## finding the like one
            path = '//button[contains(@class, "wpO6b")]'
            like_unlike = wait.until(EC.element_to_be_clickable((By.XPATH,path)))
            like_unlike.click()
        else:
            previously_like = True
            
        ## exiting the post
        exit = driver.find_element_by_class_name("ckWGn")
        exit.click()
        
        ## mainatining the number of post
        if cnt == no_of_post:
            break
        cnt += 1
        
    ## coming back to home page
    home = wait.until(EC.element_to_be_clickable((By.XPATH, '//div[@class = "oJZym"]/a')))
    home.click()
    
    return previously_like

## function to disliking the first no_of_post of a profile

def unlike(driver, profile, no_of_post):
    
    wait = WebDriverWait(driver, 10)       ## Explicit Wait
    
    previously_unlike = False
    
    ## opening profile
    search_open(driver, profile)
    
    ## Extracting The No_of_posts
    btn = driver.find_elements_by_class_name("_bz0w")
    path = "//div[contains(@class,'_bz0w')]/a"
    btn = wait.until(EC.presence_of_all_elements_located((By.XPATH,path)))
    while len(btn) < no_of_post:
        driver.execute_script('window.scrollBy(0, 1000);')         ## Scrolling
        btn = wait.until(EC.presence_of_all_elements_located((By.XPATH,path)))
        
    print("number of posts extracted: ", len(btn))
    
    cnt = 1
    for i in btn:
        i.click()
        time.sleep(3)
        
        ## Checking if ith post is liked before or not
        cond = driver.find_elements_by_xpath("//*[name()='svg']")[6]
        if(cond.get_attribute("aria-label") == "Unlike"):    ## finding the like one
            path = '//button[contains(@class, "wpO6b")]'
            like_unlike = wait.until(EC.element_to_be_clickable((By.XPATH,path)))
            like_unlike.click()
        else:
            previously_unlike = True
            
        ## exiting the post
        exit = driver.find_element_by_class_name("ckWGn")
        exit.click()
        
        ## mainatining the number of post
        if cnt == no_of_post:
            break
        cnt += 1
        
    ## coming back to home page
    home = wait.until(EC.element_to_be_clickable((By.XPATH, '//div[@class = "oJZym"]/a')))
    home.click()
    
    return previously_unlike

## 5

profile = "dilsefoodie"        ## can be changed
no_of_post = 30

## like
previously_like = like(driver, profile, no_of_post)
if(previously_like):
    print("Already one of the post is liked")
else:
    print("No Post is liked before")
    
    
time.sleep(3)

    
## unlike
previously_unlike = unlike(driver, profile, no_of_post)
if(previously_unlike):
    print("Already one of the post is not liked")
else:
    print("Unliked all now, no post is disliked before")

"""## 6. list Of Followers """

## function to extract the username of no_of_followers folllowers of a profile

def extracting_followers(driver, profile, no_of_followers):  
    
    wait = WebDriverWait(driver, 20)       ## Explicit Wait
    
    ## opening profile
    search_open(driver, profile)

    ## clicking on followers
    path = '//li[contains(@class, "Y8-fY")][2]/a'
    followers = wait.until(EC.element_to_be_clickable((By.XPATH, path)))
    followers.click()

    ## Extracting The No_of_followers
    path = '//div[@class = "PZuss"]//li'
    btn = wait.until(EC.presence_of_all_elements_located((By.XPATH,path)))

    while len(btn) < no_of_followers:
        scr1 = driver.find_element_by_xpath('/html/body/div[4]/div/div[2]')                    ## followers window
        driver.execute_script("arguments[0].scrollTop = arguments[0].scrollHeight", scr1)            ## Scrolling
        btn = wait.until(EC.presence_of_all_elements_located((By.XPATH,path)))

    print("number of followers extracted of", profile ,":", len(btn))

    ## extracting the content
    pg = driver.page_source
    data = bs4.BeautifulSoup(pg,"lxml")
    temp = data.find_all("a",{"class":"FPmhX"})

    ## making the list
    followers_ = []
    cnt = 1
    for k in temp:
        followers_.append(k.text)
        if cnt == no_of_followers:
            break
        cnt += 1

    ## exiting the followers page
    btn = driver.find_element_by_class_name("wpO6b ")
    btn.click()

    ## return to home page
    home = wait.until(EC.element_to_be_clickable((By.XPATH, '//div[@class = "oJZym"]/a')))
    home.click()
        
    return followers_

## extract followers of given list of profiles

def extract_followers_of_profiles(driver, names, no_of_followers):
    
    # list to store follower
    lst = []
    
    for profile in names:
        lst.append(extracting_followers(driver, profile, no_of_followers))
        time.sleep(3)
        
    return lst

## conversion from string to int as in instgram

def string_int(string):
    
    total = ""
    num = ['0','1','2','3','4','5','6','7','8','9']
    for i in string:
        if i in num:
            total += i
    total = int(total)
    return total

## extracting all followers of a profile 

def extracting_all_followers(driver, profile, username, no_of_followers = 1000):
    
    wait = WebDriverWait(driver, 20)              ## Explicit Wait
    
    ## opening profile
    search_open(driver, profile)
    
    ## clicking on followers
    path = '//li[contains(@class, "Y8-fY")][2]/a'
    followers = wait.until(EC.element_to_be_clickable((By.XPATH, path)))
    followers.click()
        
    ## Extracting The No_of_followers
    path = '//div[@class = "PZuss"]//li'
    btn = wait.until(EC.presence_of_all_elements_located((By.XPATH,path)))
    string =driver.find_elements_by_xpath("//span[contains(@class, 'g47SY')]")[1].get_attribute("title") 
    
    ## integer total followers
    total = string_int(string)
    
    ## Extracting followers
    for i in range((total//2)+1):
        scr1 = driver.find_element_by_xpath('/html/body/div[4]/div/div[2]')            ## followers window
        driver.execute_script("arguments[0].scrollTop = arguments[0].scrollHeight", scr1)            ## Scrolling
        time.sleep(3)
        btn = wait.until(EC.presence_of_all_elements_located((By.XPATH,path)))
        if(len(btn) >= no_of_followers):
            break
        
    print("number of followers extracted of", profile ,":", len(btn))
        
    pg = driver.page_source
    data = bs4.BeautifulSoup(pg,"lxml")
    user = data.find_all("a",{"class":"FPmhX"})
    
    ## making the list
    followers_ = []
    for temp in user:
        if temp.text == username:
            continue
        followers_.append(temp.text)   ## making a pair list
        
    ## exiting the followers page
    btn = driver.find_element_by_class_name("wpO6b ")
    btn.click()
        
    ## return to home page
    home = wait.until(EC.element_to_be_clickable((By.XPATH, '//div[@class = "oJZym"]/a')))
    home.click()
    
    return followers_

## extracting the following person username

def extracting_all_following(driver, profile, username):
    
    wait = WebDriverWait(driver, 20)              ## Explicit Wait
    
    ## opening profile
    search_open(driver, profile)
    
    ## clicking on followers
    path = '//li[contains(@class, "Y8-fY")][3]/a'
    following = wait.until(EC.element_to_be_clickable((By.XPATH, path)))
    following.click()
        
    ## Extracting The No_of_followers
    path = '//div[@class = "PZuss"]//li'
    btn = wait.until(EC.presence_of_all_elements_located((By.XPATH,path)))
    string = driver.find_elements_by_xpath("//span[contains(@class, 'g47SY')]")[1].get_attribute("title") 
    
    ## integer total following
    total = string_int(string)
    
    ## Extracting followings
    for i in range((total//2)+1):
        scr1 = driver.find_element_by_xpath('/html/body/div[4]/div/div[2]')            ## following window
        driver.execute_script("arguments[0].scrollTop = arguments[0].scrollHeight", scr1)            ## Scrolling
    
    btn = wait.until(EC.presence_of_all_elements_located((By.XPATH,path)))    
    print("number of followings extracted of", profile ,":", len(btn))
        
    pg = driver.page_source
    data = bs4.BeautifulSoup(pg,"lxml")
    user = data.find_all("a",{"class":"FPmhX"})
    
    ## making the list
    followings_ = []
    for temp in user:
        if temp.text == username:
            continue
        followings_.append(temp.text)   ## making a pair list
        
    ## exiting the followers page
    btn = driver.find_element_by_class_name("wpO6b ")
    btn.click()
        
    ## return to home page
    home = wait.until(EC.element_to_be_clickable((By.XPATH, '//div[@class = "oJZym"]/a')))
    home.click()
    
    return followings_

## extract the list of followers who follow the profile and the user follow them but they dont follow the user

def followers_follow_profile_not_mine(driver, profiles):
    
    # list to store follower
    lst = []    
    
    profile_followers = extracting_all_followers(driver, profiles[1], profiles[0])   ## considering 1000
    my_followers = extracting_all_followers(driver, profiles[0], profile[0])  
    my_following = extracting_all_following(driver, profiles[0], profiles[0])
    
    ## filteration
    for i in my_following:
        if (i[0] not in my_followers) and (i[0] in profile_followers):
            lst.append(i[0])
            
    return lst

## 6

names = ["sodelhi", "foodtalkindia"]

##extracting the followers
no_of_followers = 500                                             ## can be change
lst = extract_followers_of_profiles(driver, names, no_of_followers)         
sodelhi_followers, foodtalkindia_followers = lst[0], lst[1]

## printing the followers
print("sodelhi followers:")
cnt = 1
for i in sodelhi_followers:
    print(cnt, ". ", i)
    cnt += 1
    
print()

print("foodtalkindia followers:")
cnt = 1
for i in foodtalkindia_followers:
    print(cnt, ". ", i)
    cnt += 1
    

time.sleep(3)

## me and profile followers
profiles = [username, "foodtalkindia"] 
lst = followers_follow_profile_not_mine(driver, profiles)     ## not including username

## printing the followers
print("followers whom i follow but dont follow me , follow the profile_name i.e :", profiles[1])
cnt = 1
for i in lst:
    print(cnt, ".", i)
    cnt += 1